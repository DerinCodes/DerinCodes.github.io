<!DOCTYPE HTML>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <title>Sorting Algorithms Visualization</title>
    <link rel="stylesheet" href="assets/css/main.css">
    <noscript><link rel="stylesheet" href="assets/css/noscript.css"></noscript>
    <style>
        /* Custom styling for code blocks */
        .code-snippet {
            background-color: #2f3843;
            border-left: 4px solid #124e65;
            padding: 5px;
            margin: 20px 0;
            font-family: monospace;
            white-space: pre-wrap;
            overflow-x: auto;
            line-height: .75em;
            color: #d4d4d4;
        }
        h1, h2, h3 {
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body class="is-preload">
    <!-- Wrapper -->
    <div id="wrapper">
        <!-- Header -->
        <header id="header">
            <div class="inner">
                <!-- Logo -->
                <a href="index.html" class="logo">
                    <span class="symbol"><img src="images/logo.svg" alt="" /></span><span class="title">Sorting Visualization</span>
                </a>

                <!-- Nav -->
                <nav>
                    <ul>
                        <li><a href="#menu">Menu</a></li>
                    </ul>
                </nav>
            </div>
        </header>

        <!-- Menu -->
        <nav id="menu">
            <h2>Menu</h2>
            <ul>
					<li><a href="index.html">About Me</a></li>
					<li><a href="index.html#projects">Projects</a></li>
					<li><a href="mail.html">Contacts</a></li>
            </ul>
        </nav>

        <!-- Main Content -->
        <div id="main">
            <div class="inner">
                <section>
                    <h1>Sorting Algorithms Visualization</h1>
                    <p>This project demonstrates different sorting algorithms in C# with a visualization in Unity. Each algorithm is explained in detail, showing only the core sorting section of each script.</p>
                </section>

                <section>
                    <h2>Sorting Algorithms</h2>

                    <!-- Bubble Sort -->
                    <h3>1. Bubble Sort</h3>
                    <p><strong>Time Complexity:</strong> O(n²) in the worst and average cases, O(n) in the best case (when the array is already sorted).<br>
                    <strong>Space Complexity:</strong> O(1), as it sorts in place.</p>
                    <p>Bubble Sort repeatedly compares adjacent elements and swaps them if they are in the wrong order. It’s known for its simplicity but is inefficient for large datasets.</p>
                    <p><strong>How it works:</strong> In each pass, Bubble Sort “bubbles” the largest unsorted element to its correct position by repeatedly swapping adjacent elements. This process continues until no swaps are needed, meaning the list is sorted.</p>
                    <div class="code-snippet">
                        for (int i = 0; i &lt; arraySize - 1; i++) {<br>
                        &nbsp;&nbsp;for (int j = 0; j &lt; arraySize - i - 1; j++) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;if (values[j] &gt; values[j + 1]) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SwapValues(j, j + 1);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;}<br>
                        }
                    </div>

                    <!-- Insertion Sort -->
                    <h3>2. Insertion Sort</h3>
                    <p><strong>Time Complexity:</strong> O(n²) in the worst and average cases, O(n) in the best case (for nearly sorted data).<br>
                    <strong>Space Complexity:</strong> O(1), as it sorts in place.</p>
                    <p>Insertion Sort builds the sorted array one item at a time by inserting each element into its correct position relative to the already sorted elements. It’s efficient for small datasets and nearly sorted data.</p>
                    <p><strong>How it works:</strong> The algorithm iterates over the array and, for each element, finds its correct position in the sorted part of the array. It shifts larger elements to the right to make space for the current element.</p>
                    <div class="code-snippet">
                        for (int i = 1; i &lt; arraySize; i++) {<br>
                        &nbsp;&nbsp;int key = values[i];<br>
                        &nbsp;&nbsp;int j = i - 1;<br>
                        &nbsp;&nbsp;while (j &gt;= 0 &amp;&amp; values[j] &gt; key) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;values[j + 1] = values[j];<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;j--;<br>
                        &nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;values[j + 1] = key;<br>
                        }
                    </div>

                    <!-- Selection Sort -->
                    <h3>3. Selection Sort</h3>
                    <p><strong>Time Complexity:</strong> O(n²) in the worst, average, and best cases.<br>
                    <strong>Space Complexity:</strong> O(1), as it sorts in place.</p>
                    <p>Selection Sort divides the array into a sorted and unsorted part. It repeatedly selects the smallest element from the unsorted part and places it at the end of the sorted part.</p>
                    <p><strong>How it works:</strong> For each position in the array, Selection Sort finds the smallest element in the unsorted part and swaps it with the current position. It continues this until the array is fully sorted.</p>
                    <div class="code-snippet">
                        for (int i = 0; i &lt; arraySize - 1; i++) {<br>
                        &nbsp;&nbsp;int minIndex = i;<br>
                        &nbsp;&nbsp;for (int j = i + 1; j &lt; arraySize; j++) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;if (values[j] &lt; values[minIndex]) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minIndex = j;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;SwapValues(i, minIndex);<br>
                        }
                    </div>

                    <!-- Quick Sort -->
                    <h3>4. Quick Sort</h3>
                    <p><strong>Time Complexity:</strong> O(n log n) on average, but O(n²) in the worst case (poor pivot choice).<br>
                    <strong>Space Complexity:</strong> O(log n) for recursive stack.</p>
                    <p>Quick Sort is a divide-and-conquer algorithm. It picks a pivot element, partitions the array around the pivot, and recursively sorts the partitions.</p>
                    <p><strong>How it works:</strong> Quick Sort selects a pivot and rearranges elements so that elements smaller than the pivot come before it and elements larger come after. It then recursively sorts the partitions.</p>
                    <div class="code-snippet">
                        if (low &lt; high) {<br>
                        &nbsp;&nbsp;int pivotIndex;<br>
                        &nbsp;&nbsp;yield return StartCoroutine(Partition(low, high, result => pivotIndex = result));<br>
                        &nbsp;&nbsp;yield return QuickSortRecursive(low, pivotIndex - 1);<br>
                        &nbsp;&nbsp;yield return QuickSortRecursive(pivotIndex + 1, high);<br>
                        }
                    </div>

                    <!-- Merge Sort -->
                    <h3>5. Merge Sort</h3>
                    <p><strong>Time Complexity:</strong> O(n log n) in all cases.<br>
                    <strong>Space Complexity:</strong> O(n) due to auxiliary arrays.</p>
                    <p>Merge Sort is a stable, divide-and-conquer algorithm. It splits the array into halves, recursively sorts each half, and merges them back together. It’s highly efficient for large datasets with consistent O(n log n) time complexity.</p>
                    <p><strong>How it works:</strong> Merge Sort recursively divides the array into halves until it reaches arrays of length 1. It then merges sorted arrays back together in sorted order.</p>
                    <div class="code-snippet">
                        yield return MergeSortRecursive(left, middle);<br>
                        yield return MergeSortRecursive(middle + 1, right);<br>
                        yield return Merge(left, middle, right);<br>
                    </div>

                    <!-- Heap Sort -->
                    <h3>6. Heap Sort</h3>
                    <p><strong>Time Complexity:</strong> O(n log n) in all cases.<br>
                    <strong>Space Complexity:</strong> O(1) for in-place sorting.</p>
                    <p>Heap Sort builds a max heap and repeatedly extracts the maximum element, placing it at the end of the array. It is efficient with O(n log n) complexity but not stable.</p>
                    <p><strong>How it works:</strong> Heap Sort builds a max heap of the array, then swaps the root (largest element) with the last element, reduces the heap size, and re-heapifies. This process continues until the array is sorted.</p>
                    <div class="code-snippet">
                        for (int i = n / 2 - 1; i &gt;= 0; i--) {<br>
                        &nbsp;&nbsp;yield return Heapify(n, i);<br>
                        }<br>
                        for (int i = n - 1; i &gt; 0; i--) {<br>
                        &nbsp;&nbsp;SwapValues(0, i);<br>
                        &nbsp;&nbsp;yield return Heapify(i, 0);<br>
                        }
                    </div>
<section id="webgl-content">
    <h2>Sorting Algorithms Visualization</h2>
    <iframe src="assets/SortingAlgorithms/index.html" width="100%" height="700px" frameborder="0" allowfullscreen="true"></iframe>
</section>
        </div>
                </section>
            </div>
        <!-- Footer -->
        <footer id="footer">
            <div class="inner">
                <section>
                    <h2>Contacts</h2>
                    <ul class="icons">
                        <li><a href="https://github.com/DerinCodes" class="icon brands style2 fa-github" target="_blank"><span class="label">GitHub</span></a></li>
                        <li><a href="https://www.linkedin.com/in/derin-k-38616010b/" class="icon brands style2 fa-linkedin" target="_blank"><span class="label">LinkedIn</span></a></li>
                        <li><a href="#" class="icon solid style2 fa-envelope"><span class="label">Email</span></a></li>
                    </ul>
                </section>
            </div>
        </footer>
    </div>

    <!-- Scripts -->
    <script src="assets/js/jquery.min.js"></script>
    <script src="assets/js/browser.min.js"></script>
    <script src="assets/js/breakpoints.min.js"></script>
    <script src="assets/js/util.js"></script>
    <script src="assets/js/main.js"></script>
</body>
</html>
